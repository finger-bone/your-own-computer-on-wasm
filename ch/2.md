# 实现计算机核心系统

本章标题的**计算机系统**，并不只是指的**操作系统**。计算机系统是由硬件和软件组成的，硬件是计算机的物理部分，软件是计算机的程序。计算机系统的硬件部分包括中央处理器、存储器、输入输出设备、通信设备等。计算机系统的软件部分包括操作系统、应用软件、编程语言、数据库等。然而，因为本系列设计的计算机是**裸机**，即没有操作系统的计算机，所以本章看起来更像是设计计算机硬件的章节。

在本系列中，我们定义一个新的概念：**核心系统**(Core System)。核心系统是一个计算机系统的最小部分，包括中央处理器、内存、总线。核心系统是一个独立的计算机系统，是现代计算机中能独立工作的最小部分。核心系统可以独立工作，也可以作为一个子系统被更大的计算机系统使用。本文将实现一个核心系统。

## 整体设计

在dive into details之前，我们先来设计一下整体的计算机系统。

复习一下：一个经典的现代计算机，由五大部件组成：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器合称为中央处理器，存储器中最主要的是内存。

### 总线

同时我们引入一个新的概念：**总线**(Bus)。总线是计算机中的一种特殊的通信线路，用于连接各种硬件设备，传输数据和控制信号。注意，总线不一定只有一根线，它可以是一组线，每一根线负责传输一个数据位。总线的宽度，即一次能传输的数据位数，称为**总线宽度**。总线的速度，即一秒钟能传输的数据位数，称为**总线速度**。

按照总线的位置，我们可以把它们分类为：**系统总线**，即连接CPU、内存的总线；**I/O总线**，即连接CPU和I/O设备的总线；**外总线**，即连接计算机和其它设备的总线。

### 中断

我们将使用**中断**(interruption)机制实现I/O设备的控制。中断一词看似复杂，其实很简单：当一个I/O设备需要CPU的处理时，它会向CPU发出一个中断信号，CPU收到中断信号后，会暂停当前的工作，转而处理I/O设备的请求。处理完I/O设备的请求后，CPU会恢复之前的工作。这样，CPU就可以同时处理多个I/O设备的请求，提高了计算机的效率。

例如，如果用c语言来描述这个过程，可以这样写：

```c
int volatile interrupt = 0;
while (1) {
    if (interrupt != 0) {
        handle_interrupt();
    } else {
        run_the_program();
    }
}
```

在这段代码中，`interrupt`是一个全局变量，用于表示中断信号。`handle_interrupt()`是一个函数，用于处理中断信号。`do_something()`是一个函数，用于处理CPU的正常工作。这段代码的逻辑很简单：如果`interrupt`不为0，就处理中断信号；否则，就处理正常工作。这便是中断机制的基本原理。

我们的核心系统将通过I/O总线使CPU与外部设备通信。这条I/O总线包含三条子总线：**中断信号线**，用于CPU接受外部设备的中断信号；**中断数据线**，用于在中断时传输数据；**中断请求线**，用于CPU请求外部设备的中断。

I/O总线直接连接到CPU，但I/O总线并不直接连接到外部设备，相反，它连接到一个兼具**总线控制器**(Bus Controller)功能的I/O控制器。总线控制器是一个硬件设备，负责调度总线上的数据传输。总线控制器通过**总线接口**(Bus Interface)连接到外部设备，负责与外部设备通信。

此外，I/O控制器还能实现内存映射，即将外部设备映射到内存地址空间。这样，CPU就可以通过读写内存的方式来控制外部设备。这种方式称为**内存映射I/O**。

## 系统设计

根据上面的设计，我们可以设计一个简单的计算机系统。这个计算机系统包括一个核心系统，一个总线，一个I/O控制器，一个外部设备。

其中，核心系统包括一个中央处理器、一个内存。

### 中央处理器

再细节一点，中央处理器主要包**寄存器文件**，**算数逻辑单元**，**控制单元**。它还和内存共享一个**地址总线**，一个**数据总线**，一个**控制总线**。

当然，现实中的CPU要复杂的多，例如，一个现代的CPU还包括**浮点运算单元**，**向量运算单元**，**流水线寄存器**，**分支预测器**等等。然而，这些都不是我们的重点，我们只关心CPU的基本功能。

在本文中，我们只写一些组件，在下一章中，我们会把它们组装成核心系统。

#### 寄存器文件

寄存器文件是一个很有迷惑性的名字，它并不是一个文件，而是一组寄存器的集合。换句话说，寄存器文件就是CPU里的一组寄存器再加上一些控制逻辑。寄存器文件通常包括**通用寄存器**和**特殊寄存器**，特殊寄存器又包括**程序计数器**，**状态寄存器**，**链接寄存器**，**栈指针**等。此外，寄存器文件还支持输入寄存器编号，输出寄存器内容，写寄存器内容等操作。

在我们设计的计算机系统中，除了标志位寄存器，总共有16个寄存器，分别是`r0`到`r15`。这些寄存器中，`r15`被称为程序计数器(Program Counter, PC)，用于存放下一条指令的地址。`r14`被称为链接寄存器(Link Register, LR)，用于存放函数调用的返回地址(之后我们会详细讲解)。`r13`被称为栈指针(Stack Pointer, SP)，用于存放栈顶的地址(之后也会详细讲解)。标志位寄存器简称为`cpsr`，在我们设计的系统中，它只保存进位标志、零标志、负数标志等和溢出标志。

当然，真实的计算机中，寄存器的数量和功能都要复杂的多。现代arm64架构，根据不同的模式，有许多套寄存器，例如，用户模式下有16个通用寄存器，系统模式下有37个寄存器，还有一些特殊的寄存器，例如，程序状态寄存器，中断屏蔽寄存器，异常向量基址寄存器等。

现在我们开始编码，注意，在这里，我使用了无状态的写法。即在修改寄存器的时候，我返回了一个新的寄存器文件，而不是直接修改原来的寄存器文件。这主要是为了之后在编写可视化代码的时候方便。如果希望更贴近硬件和现实，可以使用有状态的写法。

首先定义寄存器，

```rust
#[derive(Debug)]
pub struct Reg {
    data: u64,
}

impl Reg {
    pub fn get(&self) -> u64 {
        self.data
    }
    pub fn set(self, v: u64) -> Reg {
        Reg {
            data: v
        }
    }
    pub fn new() -> Reg {
        Reg { data: 0 }
    }
}
```

标志位寄存器，因为wasm的桥接器限制，js-wasm边界上只能传输简单的数据类型，所以我们实现了解码和编码状态位到u8的函数。

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
#[derive(Clone, Copy)]
#[derive(Debug)]
pub struct Cpsr {
    pub n: bool,
    pub z: bool,
    pub c: bool,
    pub v: bool,
}

impl Cpsr {
    pub fn from_u8(nzcv: u8) -> Cpsr {
        Cpsr {
            n: ((nzcv >> 3 & 1) == 1),
            z: ((nzcv >> 2 & 1) == 1),
            c: ((nzcv >> 1 & 1) == 1),
            v: ((nzcv >> 0 & 1) == 1),
        }
    }

    pub fn to_u8(&self) -> u8 {
        ((self.n as u8) & 1) << 3
        | ((self.z as u8) & 1) << 2
        | ((self.c as u8) & 1) << 1
        | ((self.v as u8) & 1) << 0
    }
}
```

寄存器文件，这里，我们按照之前的条件码，实现了输入状态码，输出布尔值的功能。此外，压栈、弹栈、PC自增、设置LR等功能也实现了单独的函数。对于压栈，我们将栈指针减8，对于弹栈，我们将栈指针加8。对于PC自增，我们将PC加8。对于设置LR，我们将LR设置为PC的值。至于为什么这么做，我们将在之后的章节中详细讲解。如果你不理解，也可以留一个`todo!()`，之后再来填写。

```rust
use super::{cpsr::Cpsr, reg::Reg};

#[derive(Debug)]
pub enum ConditionCode {
    EQ = 0b0000, // Equal
    NE = 0b0001, // Not Equal
    HS = 0b0010, // Unsigned higher or same (or carry set)
    LO = 0b0011, // Unsigned lower (or carry clear)
    MI = 0b0100, // Negative
    PL = 0b0101, // Positive or Zero
    VS = 0b0110, // Signed Overflow
    VC = 0b0111, // No Signed Overflow
    HI = 0b1000, // Unsigned Higher
    LS = 0b1001, // Unsigned Lower or Same
    GE = 0b1010, // Signed Greater Than or Equal
    LT = 0b1011, // Signed Less Than
    GT = 0b1100, // Signed Greater Than
    LE = 0b1101, // Signed Less Than or Equal
    AL = 0b1110, // Always Executed
}

impl ConditionCode {
    pub fn from_u8(nzcv: u8) -> ConditionCode {
        match nzcv {
            0b0000 => ConditionCode::EQ,
            0b0001 => ConditionCode::NE,
            0b0010 => ConditionCode::HS,
            0b0011 => ConditionCode::LO,
            0b0100 => ConditionCode::MI,
            0b0101 => ConditionCode::PL,
            0b0110 => ConditionCode::VS,
            0b0111 => ConditionCode::VC,
            0b1000 => ConditionCode::HI,
            0b1001 => ConditionCode::LS,
            0b1010 => ConditionCode::GE,
            0b1011 => ConditionCode::LT,
            0b1100 => ConditionCode::GT,
            0b1101 => ConditionCode::LE,
            0b1110 => ConditionCode::AL,
            _ => panic!("Invalid condition code."),
        }
    }
}

pub const REG_NUMBER: usize = 16;
pub const PC: usize = 15;
pub const LR: usize = 14;
pub const SP: usize = 13;

#[derive(Debug)]
pub struct RegFile {
    regs: Vec<Reg>,
    cpsr: Cpsr,
}

impl RegFile {
    pub fn new() -> RegFile {
        RegFile {
            regs: (0..REG_NUMBER).map(|_| Reg::new()).collect(),
            cpsr: Cpsr {
                n: false,
                z: false,
                c: false,
                v: false,
            },
        }
    }

    pub fn get(&self, reg_num: u64) -> u64 {
        self.regs[reg_num as usize].get()
    }

    pub fn get_imm(&self, reg_num: u64, imm: bool) -> u64 {
        if imm {
            reg_num
        } else {
            self.regs[reg_num as usize].get()
        }
    }

    pub fn set(mut self, reg_num: u64, val: u64) -> RegFile {
        self.regs[reg_num as usize] = Reg::new().set(val);
        RegFile {
            regs: self.regs,
            cpsr: Cpsr {
                n: self.cpsr.n,
                z: self.cpsr.z,
                c: self.cpsr.c,
                v: self.cpsr.v,
            },
        }
    }
    pub fn get_cond(&self, cond_code: u64) -> bool {
        let con = ConditionCode::from_u8(cond_code as u8);
        match con {
            ConditionCode::EQ => self.cpsr.z,
            ConditionCode::NE => !self.cpsr.z,
            ConditionCode::HS => self.cpsr.c,
            ConditionCode::LO => !self.cpsr.c,
            ConditionCode::MI => self.cpsr.n,
            ConditionCode::PL => !self.cpsr.n,
            ConditionCode::VS => self.cpsr.v,
            ConditionCode::VC => !self.cpsr.v,
            ConditionCode::HI => self.cpsr.c && !self.cpsr.z,
            ConditionCode::LS => !self.cpsr.c || self.cpsr.z,
            ConditionCode::GE => self.cpsr.n == self.cpsr.v,
            ConditionCode::LT => self.cpsr.n != self.cpsr.v,
            ConditionCode::GT => !self.cpsr.z && (self.cpsr.n == self.cpsr.v),
            ConditionCode::LE => self.cpsr.z || (self.cpsr.n != self.cpsr.v),
            ConditionCode::AL => true,
        }
    }
    pub fn set_cpsr(self, nzcv: u8) -> RegFile {
        RegFile {
            regs: self.regs,
            cpsr: Cpsr::from_u8(nzcv)
        }
    }
    pub fn get_pc(&self) -> u64 {
        self.regs[PC].get()
    }
    pub fn set_lr(mut self) -> RegFile {
        self.regs[LR] = Reg::new().set(self.regs[PC].get());
        RegFile {
            regs: self.regs,
            cpsr: Cpsr {
                n: self.cpsr.n,
                z: self.cpsr.z,
                c: self.cpsr.c,
                v: self.cpsr.v,
            },
        }
    }
    pub fn push_stack(mut self) -> RegFile {
        self.regs[SP] = Reg::new().set(self.regs[SP].get() - 8);
        RegFile {
            regs: self.regs,
            cpsr: Cpsr {
                n: self.cpsr.n,
                z: self.cpsr.z,
                c: self.cpsr.c,
                v: self.cpsr.v,
            },
        }
    }
    pub fn pop_stack(mut self) -> RegFile {
        self.regs[SP] = Reg::new().set(self.regs[SP].get() + 8);
        RegFile {
            regs: self.regs,
            cpsr: Cpsr {
                n: self.cpsr.n,
                z: self.cpsr.z,
                c: self.cpsr.c,
                v: self.cpsr.v,
            },
        }
    }

    pub fn next_pc(self) -> RegFile {
        let next_pc = self.get_pc() + 8;
        self.set(
            PC as u64, next_pc
        )
    }

    pub fn dump_common(&self) -> Vec<u64> {
        self.regs.iter().map(|r| r.get()).collect()
    }

    pub fn dump_cpsr(&self) -> u8 {
        self.cpsr.to_u8()
    }
}
```

#### 系统总线

系统总线是CPU和内存之间的通信线路。系统总线包括**地址总线**，**数据总线**，**控制总线**。地址总线用于传输内存地址，数据总线用于传输数据，控制总线用于传输控制信号。

然而，因为我们在写一个模拟器，所以没必要折磨自己去全用二进制信号控制器件——代码的逻辑代替了控制总线的功能。因此，我们只需要一个地址总线和一个数据总线。

我们先来定义线（由于在其它位置也会使用，且功能相同，我们的类称为线而非总线），在我们的系统中，一般的线能传输64位数据，

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
#[derive(Clone, Copy)]
#[derive(Debug)]
pub struct Wire {
    data: u64,
}

#[wasm_bindgen]
impl Wire {
    pub fn get(&self) -> u64 {
        self.data
    }
    pub fn set(self, v: u64) -> Wire {
        Wire {
            data: v
        }
    }
    #[wasm_bindgen(constructor)]
    pub fn new() -> Wire {
        Wire { data: 0 }
    }
}
```

此外还有单线，传递一个bool值，

```rust
#[wasm_bindgen]
#[derive(Clone, Copy)]
pub struct SingleWire {
    data: bool,
}

#[wasm_bindgen]
impl SingleWire {
    pub fn get(&self) -> bool {
        self.data
    }
    pub fn set(self, v: bool) -> SingleWire {
        SingleWire {
            data: v
        }
    }
    #[wasm_bindgen(constructor)]
    pub fn new() -> SingleWire {
        SingleWire { data: false }
    }
}
```

#### 算数逻辑单元

算数逻辑单元(ALU)是CPU的核心部件，用于进行算术运算和逻辑运算。ALU的输入是两个操作数，输出是一个结果和一些标志位。ALU支持的运算包括加法、减法、乘法、除法、与、或、非、异或等。此外，尽管数据传输操作不需要运算，但为了方便，我们也会使这个过程经过ALU，方便统一处理，尽管ALU在这个过程仅负责转发数据。

我们为之前定义的所有指令定义了一个枚举类型，这样我们就可以在ALU中使用这个枚举类型来处理所有的指令。

ALU即是一个接收数据和运算，得到结果和标志位的过程。此外，除以零等异常将通过中断机制处理。因此，ALU的`cal`方法接收运算，两个操作数，返回结果，标志位和异常。

```rust
use super::{cpsr::Cpsr, instr::Operation};

pub struct Alu {}

impl Alu {
    pub fn new() -> Alu {
        Alu {}
    }
    pub fn cal(&self, op: u64, b: u64, c: u64) -> (u64, u8, u64) {
        let operation = Operation::new(op);
        match operation {
            // n z c v
            // negative, zero, carry, overflow
            Operation::Mov => {
                let result = c;
                (
                    result,
                    Cpsr {
                        n: ((c >> 63) & 1) == 1,
                        z: c == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0,
                )
            }
            Operation::Add => {
                let result = b.wrapping_add(c);
                let carry = if b > u64::MAX - c { 1 } else { 0 };
                let overflow = ((b as i64).overflowing_add(c as i64).1) as u8;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: overflow == 1,
                        c: carry == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Cmn => {
                let result = b.wrapping_add(c);
                let carry = if b > u64::MAX - c { 1 } else { 0 };
                let overflow = ((b as i64).overflowing_add(c as i64).1) as u8;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: overflow == 1,
                        c: carry == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Sub => {
                let result = b.wrapping_sub(c);
                let carry = if b < c { 1 } else { 0 };
                let overflow = ((b as i64).overflowing_sub(c as i64).1) as u8;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: overflow == 1,
                        c: carry == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Cmp => {
                let result = b.wrapping_sub(c);
                let carry = if b < c { 1 } else { 0 };
                let overflow = ((b as i64).overflowing_sub(c as i64).1) as u8;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: overflow == 1,
                        c: carry == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Mul => {
                let result = b.wrapping_mul(c);
                let carry = if b > u64::MAX / c { 1 } else { 0 };
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: carry == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Div => {
                if c == 0 {
                    return (
                        0,
                        Cpsr {
                            n: false,
                            z: false,
                            v: false,
                            c: false,
                        }
                        .to_u8(),
                        1,
                    )
                }
                let result = b / c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::SMul => {
                let result = (b as i64).wrapping_mul(c as i64) as u64;
                let overflow = ((b as i64).overflowing_mul(c as i64).1) as u8;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: overflow == 1,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::SDiv => {
                if c == 0 {
                    return (
                        0,
                        Cpsr {
                            n: false,
                            z: false,
                            v: false,
                            c: false,
                        }
                        .to_u8(),
                        1,
                    )
                }
                let result = (b as i64 / c as i64) as u64;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Modu => {
                if c == 0 {
                    return (
                        0,
                        Cpsr {
                            n: false,
                            z: false,
                            v: false,
                            c: false,
                        }
                        .to_u8(),
                        1,
                    )
                }
                let result = b % c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::SModu => {
                if c == 0 {
                   return (
                        0,
                        Cpsr {
                            n: false,
                            z: false,
                            v: false,
                            c: false,
                        }
                        .to_u8(),
                        1,
                    )
                }
                let result = (b as i64 % c as i64) as u64;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Mvn => {
                let result = !c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0,
                )
            }
            Operation::And => {
                let result = b & c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0,
                )
            }
            Operation::Tst => {
                let result = b & c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Orr => {
                let result = b | c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Eor => {
                let result = b ^ c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Teq => {
                let result = b ^ c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: false,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Lsl => {
                let result = b << c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: ((b << (c - 1)) & 0x8000000000000000) != 0,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Lsr => {
                let result = b >> c;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: ((b >> (c - 1)) & 1) == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Asr => {
                let result = (b as i64 >> c) as u64;
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: ((b as i64 >> (c - 1)) & 1) == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Rol => {
                let c = (c % 64) as u32;
                let result = b.rotate_left(c);
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: ((b.rotate_left(c - 1)) & 1) == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Ror => {
                let c = (c % 64) as u32;
                let result = b.rotate_right(c);
                (
                    result,
                    Cpsr {
                        n: ((result >> 63) & 1) == 1,
                        z: result == 0,
                        v: false,
                        c: ((b.rotate_right(c - 1)) & 1) == 1,
                    }
                    .to_u8(),
                    0
                )
            }
            Operation::Str => (c, 0, 0),
            Operation::Push => (c, 0, 0),
            Operation::Bl => (c, 0, 0),
            Operation::B => (c, 0, 0),
            Operation::Qry => (c, 0, 0),
            _ => (0, 0, 0),
        }
    }
}
```

#### 译码器

**译码器**是CPU的一个重要部件，用于将指令译码成操作码和操作数。译码器的输入是指令，输出是操作码和操作数。然而，我们之前实现的指令类已经包含了这个过程，这里的译码器仅为了显得更贴近现实。

```rust
use wasm_bindgen::prelude::*;

use super::instr::Instr;

#[wasm_bindgen]
#[derive(Clone, Copy)]
pub struct Decoder {

}

#[wasm_bindgen]
impl Decoder {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Decoder {
        Decoder {
        }
    }
    pub fn decode(self, v: u64) -> Instr {
        Instr::new(v)
    }
}
```

### 内存

在现实中，内存包含**内存控制器**，**地址译码器**，**写控制**等，而且，真实的DRAM还通过二次译码器、行缓冲器、列缓冲器等来节省位宽。然而，在我们的系统中，我们只要实现一个简单的，**字节可寻址**的内存即可。

字节可寻址是指内存中的每一个字节都有一个唯一的地址。因此，我们存储数据的结构是`vec<u8>`(使用`vec`是为了通过wasm桥，使用数组也可行)。

这是内存的实现，

```rust
pub struct Mem {
    mem: Vec<u8>,
}

impl Mem {
    pub fn new(val: Vec<u8>) -> Mem {
        Mem {
            mem: val,
        }
    }
    pub fn get_word(&self, addr: u64) -> u64 {
        let mut val = 0;
        for i in 0..8 {
            val |= (self.mem[addr as usize + i] as u64) << (8 * (8 - i - 1));
        }
        val
    }
    pub fn set_word(mut self, addr: u64, val: u64) -> Mem {
        for i in 0..8 {
            self.mem[addr as usize + i] = ((val >> (8 * (8 - i - 1))) & 0xff) as u8;
        }
        Mem {
            mem: self.mem,
        }
    }
}

impl Mem {
    pub fn dump(&self) -> Vec<u8> {
        self.mem.clone()
    }
    pub fn get_size(&self) -> usize {
        self.mem.len()
    }
}
```

此外，我们设计一个独立的内存地址计算器，用于计算内存地址。这个计算器接收基地址，偏移量和放大倍数，返回计算后的地址。

```rust
pub struct MemAddressCalculator {

}

impl MemAddressCalculator {
    pub fn new() -> MemAddressCalculator {
        MemAddressCalculator {}
    }

    pub fn calculate(&self, base: u64, offset: u64, scaler: u64) -> u64 {
        base + offset * scaler
    }
}
```

### 内存的使用

如果内存只是一个存储器，那么它就没有什么用处。我们需要规划好内存的使用方式，以便CPU能够从内存中读取指令和数据。

在现代计算机中，内存是分段的。每个段有不同的功能和权限。

一般而言，内存的低位会自底向上存储指令。这一部分内存称为**代码段**。代码段的大小是固定的，现代计算机中一般是4GB。代码段的起始地址是0x0。不过，在现实的计算机中，这个地址是逻辑地址，需要通过MMU转换为物理地址。这一段是只读且可执行的。

代码段再往上是**数据段**。如果你编写的汇编代码，那么你是通过特殊的**伪指令**来定义数据段的。你可以在这一段里填入任意的内容。但是，如果你使用的C语言，那么这一段将会被编译器填入全局变量与静态变量——你大概也能理解C语言中静态变量的一些行为了，例如，全局变量和静态变量的大小必须在编译时确定——因为它们是在编译时分配内存的；静态变量的生命周期是整个程序的生命周期——因为它们是在程序启动时分配内存的；静态变量只有一份内存等等。

数据段又是会被分成**静态数据段**和**只读数据段**。静态数据段是可读可写的，只读数据段是只读的。

再往上，是**堆栈段**。这里的堆并不是数据结构中的堆，而是单词heap的原意，即堆积。堆栈会共享同一个数据段，这段内存是可读可写的。

堆栈段分为堆内存和栈内存。局部变量都是在栈内存中分配的，栈内存存储变量的特点是，它们都有确定的长度和生命周期；堆内存存储的是动态分配的内存，它们的长度和生命周期是不确定的。在大部分情况下，堆内存是通过`malloc`和`free`来分配和释放的。

注意，在面向对象语言（例如C++）中，尽管使用new创建对象的方法看起来好似是创建局部变量，但实际上，它是在堆内存中分配内存，返回的是指向这个内存的指针，这个指针是一个局部变量，存储在栈内存中。

堆内存和栈内存有不同的管理方式和特点。

对于栈内存，它占据的内存是连续的，是从内存的最高位向下分配的——它是个倒置的栈。SP寄存器指向栈顶，每次分配内存，SP减去分配的内存大小；每次释放内存，SP加上释放的内存大小。因为栈内存是连续的，而且分配和释放是进行寄存器操作，所以栈内存的分配和释放是非常快的。对于小型数据，例如局部变量，它们的生命周期是函数调用的生命周期，所以栈内存是非常适合存储这些数据的。不过，栈内存的缺点是，它的大小是固定的——我们不允许栈顶低于某个特定的值，否则，我们其它段的数据可能会被覆盖，这就是为什么栈溢出不止是一个程序崩溃的问题，还可能是一个安全问题。在从前，栈溢出是黑客攻击的一个重要手段。不过今天，由于权限机制的加强，这种攻击方式已经不再流行。

对于堆内存，它的分配和释放是通过系统调用来进行的。堆内存是不连续的，它的分配和释放是通过链表来进行的。因为堆内存是不连续的，所以它的分配和释放是比较慢的。不过，堆内存的优点是，它的大小是动态的，我们可以分配任意大小的内存。堆内存的缺点是，它的生命周期是不确定的，我们需要手动释放内存，否则，就会造成内存泄漏。

### 系统连接

上文中，我们只说明了CPU的一些组件，现在我们要描述他们之间连接和通信的方式，形成一个完整核心系统。

首先，核心系统中，有一条**地址总线**，一条**数据总线**，一条**控制总线**。地址总线用于传输内存地址，数据总线用于传输数据，控制总线用于传输控制信号。**控制总线**将由代码逻辑代替，因此我们只需要**地址总线**和**数据总线**。

CPU和内存可以通过**地址总线**和**数据总线**通信。CPU通过**地址总线**向内存发送地址，通过**数据总线**向内存发送数据。内存通过**地址总线**接收CPU发送的地址，通过**数据总线**接收CPU发送的数据。

在冯诺伊曼体系结构中，指令和数据是等价的，且以相同的方式存储在内存中。因此，对计算机系统的一个粗线条的描述可以是：

1. CPU从内存中读取指令
2. CPU执行指令

然而，只有这些知识是不够的，我们还需要更细节的描述——不过这是下文的任务。

现在，我们先定义好我们需要的所有线和器件，组成核心系统——尽管它还不能工作。

```rust
pub struct CoreSys {
    pub op: Wire,
    pub cond: Wire,
    pub r_a: Wire,
    pub r_b: Wire,
    pub r_c: Wire,
    pub r_c_imm: SingleWire,
    pub r_d_mem: Wire,
    pub out_a: Wire,
    pub out_b: Wire,
    pub out_c: Wire,
    pub out_d_mem: Wire,
    pub out_m_b: Wire,
    pub out_m_o: Wire,
    pub out_m_s: Wire,
    pub addr_bus: Wire,
    pub data_bus: Wire,
    pub instr: Wire,
    pub pc_mem: Wire,
    pub write_flags: SingleWire,
    pub write_regs: SingleWire,
    pub int_data: Wire,
    pub int: Wire,
    pub query: Wire,

    int_table: Vec<u64>,
    memory: Mem,
    decoder: Decoder,
    alu: Alu,
    mem_cal: MemAddressCalculator,
    reg_file: RegFile,
}

#[wasm_bindgen]
impl CoreSys {
    #[wasm_bindgen(constructor)]
    pub fn new() -> CoreSys {
        let mut ret = CoreSys {
            op: Wire::new(),
            cond: Wire::new(),
            r_a: Wire::new(),
            r_b: Wire::new(),
            r_c: Wire::new(),
            r_c_imm: SingleWire::new(),
            r_d_mem: Wire::new(),
            out_a: Wire::new(),
            out_b: Wire::new(),
            out_c: Wire::new(),
            out_d_mem: Wire::new(),
            out_m_b: Wire::new(),
            out_m_o: Wire::new(),
            out_m_s: Wire::new(),
            addr_bus: Wire::new(),
            data_bus: Wire::new(),
            instr: Wire::new(),
            write_flags: SingleWire::new(),
            pc_mem: Wire::new(),
            write_regs: SingleWire::new(),
            int_data: Wire::new(),
            int: Wire::new(),
            query: Wire::new(),

            int_table: Vec::new(),
            memory: Mem::new(vec![0; MEM_SIZE]),
            decoder: Decoder::new(),
            alu: Alu::new(),
            mem_cal: MemAddressCalculator::new(),
            reg_file: RegFile::new(),
        };
        ret = ret.set_pc_sp();
        ret
    }
}

#[wasm_bindgen]
impl CoreSys {
    pub fn dump_mem(&self) -> Vec<u8> {
        self.memory.dump()
    }
    pub fn dump_common_regs(&self) -> Vec<u64> {
        self.reg_file.dump_common()
    }
    pub fn dump_cpsr(&self) -> u8 {
        self.reg_file.dump_cpsr()
    }
}
```

## 系统的实现

在这一部分中，我们会实现核心系统的逻辑，使其能够工作。

首先，我们要了解在计算机运行的过程中，到底发生了什么。

### 指令的执行

在现代计算机中，指令的执行是一个复杂的过程。指令的执行包括**取指**(fetch)，**译码**(decode)，**执行**(execute)，**访存**(memory access)，**写回**(write back)五个阶段。有些时候，取指和访存会合并为一个阶段。

这五个阶段并非都是必须执行的，有些命令会在逻辑上省去一些阶段。例如，数据处理指令不会有访存阶段。

接下来，我们来解释五个阶段的细节内容。

1. **取指**

    CPU从内存中读取指令。更详细的讲，我们的CPU内部有一个**程序计数器**，用于存放下一条指令的地址。在取指阶段，CPU会把PC寄存器的信息发送到内存，内存会返回PC寄存器地址处存放的数据——即二进制指令。在取指阶段，PC寄存器会自增，指向下一条指令。在我们的系统中，使用64位指令，且内存是字节可寻址的，因此，每次取指，PC寄存器会自增8。然而，对于其它的系统，这个值会不同。例如，在真实的ARM架构中，PC寄存器会自增4；在x86架构中，由于使用了变长指令，PC寄存器的自增值会根据指令的长度而变化。

    由此，不难写出取指阶段的代码，

```rust
pub fn fetch(mut self) -> CoreSys {
    self.instr = self.instr.set(
        self.memory.get_word(
            self.reg_file.get_pc()
        )
    );
    self.reg_file = self.reg_file.next_pc();
    self
}
```

    我们在前文中为寄存器文件实现了`next_pc`方法，用于将PC寄存器自增8，以及`get_pc`方法，用于获取PC寄存器的值。

2. **译码**

    CPU对指令进行译码，将指令译码成操作码和操作数，并把它们送到对应的线上(不一定是总线)。此外，我们的系统中，会把译码和读寄存器分离成两个阶段，但一般而言，这两个阶段是合并的。

```rust
pub fn decode(mut self) -> CoreSys {
    let instr = self.decoder.decode(self.instr.get());
    self.op = self.op.set(instr.op_code);
    self.cond = self.cond.set(instr.cond_code);
    self.r_d_mem = self.r_d_mem.set(instr.reg_d_mem);
    self.r_a = self.r_a.set(instr.reg_a);
    self.r_b = self.r_b.set(instr.reg_b);
    self.r_c = self.r_c.set(instr.reg_c);
    self.r_c_imm = self.r_c_imm.set(instr.c_is_imm);
    self.write_flags = self.write_flags.set(instr.set_flags);
    let decoded_op = Operation::new(instr.op_code);
    if decoded_op == Operation::B {
        self.r_d_mem = self.r_d_mem.set(
            PC as u64
        )
    } else if decoded_op == Operation::Bl {
        self.reg_file = self.reg_file.set_lr();
        self.r_d_mem = self.r_d_mem.set(
            PC as u64
        )
    }
    if decoded_op == Operation::Push {
        let next_sp = self.reg_file.get(SP as u64) - 8;
        self.reg_file = self.reg_file.set(
            SP as u64, next_sp
        )
    }
    self.write_regs = self.write_regs.set(
        !(decoded_op == Operation::Cmp || decoded_op == Operation::Cmn || decoded_op == Operation::Teq || decoded_op == Operation::Tst) || instr.set_flags
    );
    self
}
```

    对于一些特殊的指令，我们也会在译码阶段处理——例如`bl`指令，这个指令即是跳转指令，也会把当前PC寄存器的值存入LR寄存器。这违反了我们的设计原则，也一定程度上破坏了各个阶段的独立性，但这是为了简化系统的实现。`push`指令也是如此，读到改指令，会把SP寄存器的值减8（机器字长）。

    如果是在硬件设计中，你可以想象我们给寄存器文件单独留出了一个接口，如果收到`bl`指令，寄存器文件会自动设置LR寄存器。不过，这并不是真实的情况，我们只是为了简化系统的实现。

    此外，可以注意到，对于`bl`和`b`指令，我们会把PC寄存器的值存入`r_d_mem`寄存器。因为分支指令本质上是操纵PC寄存器的数据处理指令——在有些指令集中，没有显示的分支指令，分支是通过手动修改PC寄存器实现的。因此，把PC设置为目的寄存器也不难理解了。

    然后是读寄存器阶段，

```rust
pub fn read_reg(mut self) -> CoreSys {
    let op_type: OperationType = decode_op_type(self.op.get());
    match op_type {
        OperationType::DataProc | OperationType::Special | OperationType::Branch => {
            self.out_a = self.out_a.set(self.reg_file.get(self.r_a.get()));
            self.out_b = self.out_b.set(self.reg_file.get(self.r_b.get()));
            self.out_c = self.out_c.set(self.reg_file.get_imm(self.r_c.get(), self.r_c_imm.get()));
        }
        OperationType::Mem => {
            self.out_m_b = self.out_m_b.set(self.reg_file.get(self.r_a.get()));
            self.out_m_o = self.out_m_o.set(self.reg_file.get(self.r_b.get()));
            self.out_m_s = self.out_m_s.set(self.reg_file.get_imm(self.r_c.get(), self.r_c_imm.get()));
            self.out_d_mem = self.out_d_mem.set(self.reg_file.get(self.r_d_mem.get()));
        }
    }
    self
}
```

    我们为内存地址的计算设计了单独的元件和线路，因此内存地址的三条数据与其它指令的数据是分离的。当然，你也可以设计成一条总线，这样会更加简单。此外，也可以把内存地址的计算放在译码阶段。

3. **执行**

    CPU执行指令。在我们的系统中，执行指令是通过ALU来完成的。ALU接收操作码和操作数，返回结果和标志位，还有用于异常处理的中断。计算完成后，ALU会把数据写到数据总线上，并设置标志位与中断。此外，对于一些特殊指令，我们会在执行阶段处理——例如`mvi`指令，这个指令会把中断数据写入到数据总线上；`qry`指令，这个指令会把数据总线的数据写入到中断请求线上。

```rust
pub fn execute(mut self) -> CoreSys {
    let code_type = decode_op_type(self.op.get());
    if code_type == OperationType::Mem {
        self.data_bus = self.data_bus.set(self.out_d_mem.get());
    } else {
        let (result, flags, interruption) = self.alu.cal(self.op.get(), self.out_b.get(), self.out_c.get());
        self.int = self.int.set(interruption);
        self.data_bus = self.data_bus.set(result);
        if self.write_flags.get() {
            self.reg_file = self.reg_file.set_cpsr(flags);
        }
    }
    let op = decode_op(self.op.get());
    if op == Operation::Mvi {
        self.data_bus = self.data_bus.set(
            self.int_data.get()
        );
    } else if op == Operation::Qry {
        self.query = self.query.set(
            self.data_bus.get()
        );
    }
    self
}
```

4. **访存**

    CPU访问内存。首先使用内存地址计算器计算内存地址，然后把内存地址发送到内存，内存返回数据。在我们的系统中，内存访问是通过数据总线和地址总线完成的。内存访问完成后，数据会写回到数据总线上。

```rust
pub fn mem(mut self) -> CoreSys {
    self.addr_bus = self.addr_bus.set(
        self.mem_cal.calculate(self.out_m_b.get(), self.out_m_o.get(), self.out_m_s.get())
    );
    let op_code = Operation::new(self.op.get());
    match op_code {
        Operation::Ldr => {
            self.data_bus = self.data_bus.set(
                self.memory.get_word(self.addr_bus.get())
            );
        },
        Operation::Str => {
            self.memory = self.memory.set_word(self.addr_bus.get(), self.data_bus.get());
        },
        Operation::Push => {
            self.memory = self.memory.set_word(self.reg_file.get(SP as u64), self.data_bus.get());
        }
        Operation::Pop => {
            self.data_bus = self.data_bus.set(
                self.memory.get_word(self.reg_file.get(SP as u64))
            )
        }
        _ => {

        }
    };
    self
}
```

5. **写回**

    在这个阶段，数据总线上的数据会被寄存器文件识别，寄存器文件根据写使能信号决定是否写入数据。写入的目的寄存器即为`r_d_mem`寄存器。

    此外，对于弹栈指令，我们会在这一步把SP寄存器的值加8。

```rust
pub fn write_back(mut self) -> CoreSys {
    let op: Operation = decode_op(self.op.get());
    if op == Operation::Pop {
        let next_sp = self.reg_file.get(SP as u64) + 8;
        self.reg_file = self.reg_file.set(
            SP as u64, next_sp
        )
    }
    self.reg_file = self.reg_file.set(
        self.r_d_mem.get(), self.data_bus.get()
    );
    self
}
```

此外，我们还需要考虑中断。中断的处理是通过中断表来完成的。中断表是一个向量，存放中断处理函数的地址。当CPU收到中断请求时，CPU会根据中断请求的编号，从中断表中读取中断处理函数的地址，然后跳转到这个地址——相当于进行一次`bl`跳转。之后，在中断处理完成后，中断处理函数会用`bx lr`指令返回到中断请求的下一条指令。

```rust
pub fn set_int_table(mut self, table: Vec<u64>) -> CoreSys {
    self.int_table = table;
    self
}

// part of the step() function that handles interrupt
if self.int.get() != 0 {
    // bl to the interrupt handler
    let handler = self.int_table[self.int.get() as usize];
    self.reg_file = self.reg_file.set_lr();
    self.reg_file = self.reg_file.set(
        PC as u64, handler
    );
    self.int = self.int.set(0);
    return self;
}
```

这样，五个阶段和中断处理分别被实现了。接下来，我们要实现一个循环，使得CPU能够不断地执行指令。此外，我们还需要根据不同的指令，控制不同阶段是否被执行，以及处理中断等。

```rust
pub fn step(mut self) -> CoreSys {
    if self.halted() {
        return self;
    }
    if self.int.get() != 0 {
        // bl to the interrupt handler
        let handler = self.int_table[self.int.get() as usize];
        self.reg_file = self.reg_file.set_lr();
        self.reg_file = self.reg_file.set(
            PC as u64, handler
        );
        self.int = self.int.set(0);
        return self;
    }
    self = self.fetch();
    self = self.decode();
    let op = Operation::new(self.op.get());
    if op == Operation::Nop {
        return self;
    } else if op == Operation::Hlt {
        return self;
    }
    self = self.read_reg();
    if self.reg_file.get_cond(self.cond.get()) {
        if op == Operation::Int {
            let out_b = self.out_b.get();
            let out_c = self.out_c.get();
            self = self.interrupt(out_b, out_c);
            return self;
        }
        self = self.execute();
        let op_type = OperationType::new(self.op.get());
        if op_type == OperationType::Mem {
            self = self.mem();
        }
        if self.write_regs.get() {
            self = self.write_back();
        }
    }
    self
}
```

这样，我们的CPU就完成了。此外，我们还定义了一些辅助函数，例如，`halted`函数，用于判断CPU是否处于停机状态；`interrupt`函数，用于处理中断请求；`set_pc_sp`函数，在系统启动前设置好寄存器；`load_mem`，将程序载入内存。总而言之，完整的核心系统实现如下。

```rust
use wasm_bindgen::prelude::*;
use super::alu::Alu;
use super::decoder::Decoder;
use super::mem_addr_calculator::MemAddressCalculator;
use super::wire::{SingleWire, Wire};
use super::mem::Mem;
use super::instr::*;
use super::reg_file::*;

pub const MEM_SIZE: usize = 4 * 1024;

#[wasm_bindgen]
pub struct CoreSys {
    pub op: Wire,
    pub cond: Wire,
    pub r_a: Wire,
    pub r_b: Wire,
    pub r_c: Wire,
    pub r_c_imm: SingleWire,
    pub r_d_mem: Wire,
    pub out_a: Wire,
    pub out_b: Wire,
    pub out_c: Wire,
    pub out_d_mem: Wire,
    pub out_m_b: Wire,
    pub out_m_o: Wire,
    pub out_m_s: Wire,
    pub addr_bus: Wire,
    pub data_bus: Wire,
    pub instr: Wire,
    pub pc_mem: Wire,
    pub write_flags: SingleWire,
    pub write_regs: SingleWire,
    pub int_data: Wire,
    pub int: Wire,
    pub query: Wire,

    int_table: Vec<u64>,
    memory: Mem,
    decoder: Decoder,
    alu: Alu,
    mem_cal: MemAddressCalculator,
    reg_file: RegFile,
}

#[wasm_bindgen]
impl CoreSys {
    #[wasm_bindgen(constructor)]
    pub fn new() -> CoreSys {
        let mut ret = CoreSys {
            op: Wire::new(),
            cond: Wire::new(),
            r_a: Wire::new(),
            r_b: Wire::new(),
            r_c: Wire::new(),
            r_c_imm: SingleWire::new(),
            r_d_mem: Wire::new(),
            out_a: Wire::new(),
            out_b: Wire::new(),
            out_c: Wire::new(),
            out_d_mem: Wire::new(),
            out_m_b: Wire::new(),
            out_m_o: Wire::new(),
            out_m_s: Wire::new(),
            addr_bus: Wire::new(),
            data_bus: Wire::new(),
            instr: Wire::new(),
            write_flags: SingleWire::new(),
            pc_mem: Wire::new(),
            write_regs: SingleWire::new(),
            int_data: Wire::new(),
            int: Wire::new(),
            query: Wire::new(),

            int_table: Vec::new(),
            memory: Mem::new(vec![0; MEM_SIZE]),
            decoder: Decoder::new(),
            alu: Alu::new(),
            mem_cal: MemAddressCalculator::new(),
            reg_file: RegFile::new(),
        };
        ret = ret.set_pc_sp();
        ret
    }
}

#[wasm_bindgen]
impl CoreSys {
    pub fn dump_mem(&self) -> Vec<u8> {
        self.memory.dump()
    }
    pub fn dump_common_regs(&self) -> Vec<u64> {
        self.reg_file.dump_common()
    }
    pub fn dump_cpsr(&self) -> u8 {
        self.reg_file.dump_cpsr()
    }
}

#[wasm_bindgen]
impl CoreSys {
    pub fn fetch(mut self) -> CoreSys {
        self.instr = self.instr.set(
            self.memory.get_word(
                self.reg_file.get_pc()
            )
        );
        self.reg_file = self.reg_file.next_pc();
        self
    }
    pub fn set_int_table(mut self, table: Vec<u64>) -> CoreSys {
        self.int_table = table;
        self
    }
    pub fn decode(mut self) -> CoreSys {
        let instr = self.decoder.decode(self.instr.get());
        self.op = self.op.set(instr.op_code);
        self.cond = self.cond.set(instr.cond_code);
        self.r_d_mem = self.r_d_mem.set(instr.reg_d_mem);
        self.r_a = self.r_a.set(instr.reg_a);
        self.r_b = self.r_b.set(instr.reg_b);
        self.r_c = self.r_c.set(instr.reg_c);
        self.r_c_imm = self.r_c_imm.set(instr.c_is_imm);
        self.write_flags = self.write_flags.set(instr.set_flags);
        let decoded_op = Operation::new(instr.op_code);
        if decoded_op == Operation::B {
            self.r_d_mem = self.r_d_mem.set(
                PC as u64
            )
        } else if decoded_op == Operation::Bl {
            self.reg_file = self.reg_file.set_lr();
            self.r_d_mem = self.r_d_mem.set(
                PC as u64
            )
        }
        if decoded_op == Operation::Push {
            let next_sp = self.reg_file.get(SP as u64) - 8;
            self.reg_file = self.reg_file.set(
                SP as u64, next_sp
            )
        }
        self.write_regs = self.write_regs.set(
            !(decoded_op == Operation::Cmp || decoded_op == Operation::Cmn || decoded_op == Operation::Teq || decoded_op == Operation::Tst) || instr.set_flags
        );
        self
    }
    pub fn read_reg(mut self) -> CoreSys {
        let op_type: OperationType = decode_op_type(self.op.get());
        match op_type {
            OperationType::DataProc | OperationType::Special | OperationType::Branch => {
                self.out_a = self.out_a.set(self.reg_file.get(self.r_a.get()));
                self.out_b = self.out_b.set(self.reg_file.get(self.r_b.get()));
                self.out_c = self.out_c.set(self.reg_file.get_imm(self.r_c.get(), self.r_c_imm.get()));
            }
            OperationType::Mem => {
                self.out_m_b = self.out_m_b.set(self.reg_file.get(self.r_a.get()));
                self.out_m_o = self.out_m_o.set(self.reg_file.get(self.r_b.get()));
                self.out_m_s = self.out_m_s.set(self.reg_file.get_imm(self.r_c.get(), self.r_c_imm.get()));
                self.out_d_mem = self.out_d_mem.set(self.reg_file.get(self.r_d_mem.get()));
            }
        }
        self
    }
    pub fn execute(mut self) -> CoreSys {
        let code_type = decode_op_type(self.op.get());
        if code_type == OperationType::Mem {
            self.data_bus = self.data_bus.set(self.out_d_mem.get());
        } else {
            let (result, flags, interruption) = self.alu.cal(self.op.get(), self.out_b.get(), self.out_c.get());
            self.int = self.int.set(interruption);
            self.data_bus = self.data_bus.set(result);
            if self.write_flags.get() {
                self.reg_file = self.reg_file.set_cpsr(flags);
            }
        }
        let op = decode_op(self.op.get());
        if op == Operation::Mvi {
            self.data_bus = self.data_bus.set(
                self.int_data.get()
            );
        } else if op == Operation::Qry {
            self.query = self.query.set(
                self.data_bus.get()
            );
        }
        self
    }
    pub fn mem(mut self) -> CoreSys {
        self.addr_bus = self.addr_bus.set(
            self.mem_cal.calculate(self.out_m_b.get(), self.out_m_o.get(), self.out_m_s.get())
        );
        let op_code = Operation::new(self.op.get());
        match op_code {
            Operation::Ldr => {
                self.data_bus = self.data_bus.set(
                    self.memory.get_word(self.addr_bus.get())
                );
            },
            Operation::Str => {
                self.memory = self.memory.set_word(self.addr_bus.get(), self.data_bus.get());
            },
            Operation::Push => {
                self.memory = self.memory.set_word(self.reg_file.get(SP as u64), self.data_bus.get());
            }
            Operation::Pop => {
                self.data_bus = self.data_bus.set(
                    self.memory.get_word(self.reg_file.get(SP as u64))
                )
            }
            _ => {

            }
        };
        self
    }
    pub fn interrupt(mut self, int: u64, data: u64) -> CoreSys {
        self.int = self.int.set(int);
        self.int_data = self.int_data.set(data);
        self
    }
    pub fn write_back(mut self) -> CoreSys {
        let op: Operation = decode_op(self.op.get());
        if op == Operation::Pop {
            let next_sp = self.reg_file.get(SP as u64) + 8;
            self.reg_file = self.reg_file.set(
                SP as u64, next_sp
            )
        }
        self.reg_file = self.reg_file.set(
            self.r_d_mem.get(), self.data_bus.get()
        );
        self
    }
    pub fn load_mem(mut self, val: Vec<u8>) -> CoreSys {
        let mut loaded_mem = vec![0; MEM_SIZE];
        for i in 0..val.len() {
            loaded_mem[i] = val[i];
        }
        self.memory = Mem::new(loaded_mem);
        self
    }
    pub fn set_pc_sp(mut self) -> CoreSys {
        self.reg_file = self.reg_file.set(
            PC as u64, 0
        );
        self.reg_file = self.reg_file.set(
            SP as u64, self.memory.get_size() as u64
        );
        self
    }
    pub fn halted(&self) -> bool {
        let op = Operation::new(self.op.get());
        op == Operation::Hlt
    }

    pub fn step(mut self) -> CoreSys {
        if self.halted() {
            return self;
        }
        if self.int.get() != 0 {
            // bl to the interrupt handler
            let handler = self.int_table[self.int.get() as usize];
            self.reg_file = self.reg_file.set_lr();
            self.reg_file = self.reg_file.set(
                PC as u64, handler
            );
            self.int = self.int.set(0);
            return self;
        }
        self = self.fetch();
        self = self.decode();
        let op = Operation::new(self.op.get());
        if op == Operation::Nop {
            return self;
        } else if op == Operation::Hlt {
            return self;
        }
        self = self.read_reg();
        if self.reg_file.get_cond(self.cond.get()) {
            if op == Operation::Int {
                let out_b = self.out_b.get();
                let out_c = self.out_c.get();
                self = self.interrupt(out_b, out_c);
                return self;
            }
            self = self.execute();
            let op_type = OperationType::new(self.op.get());
            if op_type == OperationType::Mem {
                self = self.mem();
            }
            if self.write_regs.get() {
                self = self.write_back();
            }
        }
        self
    }
}

#[wasm_bindgen]
impl CoreSys {
    pub fn get_reg(&self, idx: u64) -> u64 {
        self.reg_file.get(idx)
    }
    pub fn get_next_instr(&self) -> u64 {
        self.memory.get_word(self.reg_file.get_pc())
    }
    pub fn print(&self) {
        println!("op: {:b}", self.op.get());
        println!("cond: {}", self.cond.get());
        println!("r_a: {}", self.r_a.get());
        println!("r_b: {}", self.r_b.get());
        println!("r_c: {}", self.r_c.get());
        println!("r_c_imm: {}", self.r_c_imm.get());
        println!("r_d_mem: {}", self.r_d_mem.get());
        println!("out_a: {}", self.out_a.get());
        println!("out_b: {}", self.out_b.get());
        println!("out_c: {}", self.out_c.get());
        println!("out_d_mem: {}", self.out_d_mem.get());
        println!("out_m_b: {}", self.out_m_b.get());
        println!("out_m_o: {}", self.out_m_o.get());
        println!("out_m_s: {}", self.out_m_s.get());
        println!("addr_bus: {}", self.addr_bus.get());
        println!("data_bus: {}", self.data_bus.get());
        println!("instr: {}", self.instr.get());
        println!("write_flags: {}", self.write_flags.get());
        println!("pc_mem: {}", self.pc_mem.get());
        println!("CPSR: {}", self.reg_file.dump_cpsr());
        println!("Register,");
        println!("{:?}", self.reg_file.dump_common());
        println!("Interruption: {}", self.int.get());
    }
    pub fn dump_int_table(&self) -> Vec<u64> {
        self.int_table.clone()
    }
    pub fn get_qry(&self) -> u64 {
        self.query.get()
    }
    pub fn get_int_data(&self) -> u64 {
        self.int_data.get()
    }
    pub fn get_int(&self) -> u64 {
        self.int.get()
    }
}
```

现在，我们的CPU就完成了。现在，我们先通过`load_mem`函数载入程序，然后通过`set_pc_sp`设置好程序计数器和栈指针，最后通过`step`函数逐步执行指令。

## 测试

现在，我们终于可以计算`1 + 1`了！这可能是复杂度最高的`1 + 1`计算方法之一。

```rust
let mut sys = CoreSys::new();
    sys = sys.load_mem(vec![
        // mov r1, #1
        // mov r2, #1
        // add r0, r1, r2
        //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
        // mov r1, #1
        0b1110_0101, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
        // mov r2, #1
        0b1110_0101, 0b0000_0000, 0b0000_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
        // add r0, r1, r2
        0b1110_0001, 0b0000_0000, 0b0001_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0010,
    ]);
    sys = sys.step();
    assert_eq!(sys.get_reg(1), 1);
    sys = sys.step();
    assert_eq!(sys.get_reg(2), 1);
    sys = sys.step();
    assert_eq!(sys.get_reg(0), 2);
```

如果你通过了测试，那么恭喜你！你已经完成了一个简单的CPU的设计和实现。现在，你可以编写任意的二进制代码，然后通过这个CPU来执行。理论上，因为我们的系统是图灵完备的，所以你可以实现任何你想要的功能。

以下是一些测试，

```rust
#[cfg(test)]
mod test_emulator {
    use crate::emulator::{core_sys::MEM_SIZE, instr::instr_to_string, reg_file::PC, CoreSys};

    #[test]
    fn test_one_plus_one() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // mov r1, #1
            // mov r2, #1
            // add r0, r1, r2
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r1, #1
            0b1110_0101, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // mov r2, #1
            0b1110_0101, 0b0000_0000, 0b0000_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // add r0, r1, r2
            0b1110_0001, 0b0000_0000, 0b0001_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0010,
        ]);
        sys = sys.step();
        assert_eq!(sys.get_reg(1), 1);
        sys = sys.step();
        assert_eq!(sys.get_reg(2), 1);
        sys = sys.step();
        assert_eq!(sys.get_reg(0), 2);
    }

    #[test]
    fn test_cond() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // mov r0, #1
            // mov r1, #1
            // subs r0, r1, #1
            // moveq r2, #1
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r0, #1
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // mov r1, #1
            0b1110_0101, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // subs r0, r1, #1
            0b1110_1101, 0b0000_0000, 0b0010_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // moveq r2, #1
            0b0000_0101, 0b0000_0000, 0b0000_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
        ]);
        sys = sys.step();
        assert_eq!(sys.get_reg(0), 1);
        sys = sys.step();
        assert_eq!(sys.get_reg(1), 1);
        sys = sys.step();
        assert_eq!(sys.get_reg(0), 0);
        assert_eq!(sys.dump_cpsr(), 0b0100);
        sys = sys.step();
        assert_eq!(sys.get_reg(2), 1);
    }

    #[test]
    fn test_b() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // b #16
            // mov r1, #1
            // mov r2, #1
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // b #16
            0b1110_0111, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0001_0000,
            // mov r1, #1
            0b1110_0101, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // mov r2, #1
            0b1110_0101, 0b0000_0000, 0b0000_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
        ]);
        sys = sys.step();
        assert_eq!(sys.get_reg(15), 16);
        sys = sys.step();
        assert_ne!(sys.get_reg(1), 1);
        assert_eq!(sys.get_reg(2), 1);
    }

    #[test]
    fn test_cond_and_b() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // mov r0, #1
            // cmp r0, #1
            // beq #32
            // mov r1, #1
            // hlt
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r0, #1
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // cmp r0, #1
            0b1110_1101, 0b0000_0001, 0b0101_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // beq #32
            0b0000_0111, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0010_0000,
            // mov r1, #1
            0b1110_0101, 0b0000_0001, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // hlt
            0b1110_0000, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
        ]);
        sys = sys.step();
        assert_eq!(sys.get_reg(0), 1);
        sys = sys.step();
        assert_eq!(sys.dump_cpsr(), 0b0100);
        sys = sys.step();
        assert_eq!(sys.get_reg(15), 32);
        assert_ne!(sys.get_reg(1), 1);
    }
    #[test]
    fn test_fib() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // mov r0, #0
            // mov r1, #1
            // mov r2, #0
            // mov r3, #8
            // LOOP: add r2, r0, r1
            // mov r0, r1
            // mov r1, r2
            // subs r3, r3, #1
            // bne =LOOP
            // hlt
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r0, #0
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // mov r1, #1
            0b1110_0101, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // mov r2, #0
            0b1110_0101, 0b0000_0000, 0b0000_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // mov r3, #8
            0b1110_0101, 0b0000_0000, 0b0000_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_1000,
            // LOOP: add r2, r0, r1
            0b1110_0001, 0b0000_0000, 0b0001_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // mov r0, r1
            0b1110_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // mov r1, r2
            0b1110_0001, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0010,
            // subs r3, r3, #1
            0b1110_1101, 0b0000_0000, 0b0010_0011, 0b0000_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // bne LOOP
            0b0001_0111, 0b0000_0000, 0b0000_0000, 0b0000_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0010_0000,
            // hlt
            0b1110_0000, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
        ]);
        while !sys.halted() {
            println!("{}", instr_to_string(sys.get_next_instr()));
            sys = sys.step();
        }
        assert_eq!(sys.get_reg(0), 21);
    }
    #[test]
    fn test_str_and_ldr() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // sp is r13
            // mov r0, #255
            // sub sp, sp, #8
            // str r0, sp
            // ldr r1, sp
            // hlt
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r0, #255
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b1111_1111,
            // sub sp, sp, #8
            0b1110_0101, 0b0000_0000, 0b0010_1101, 0b0000_1101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_1000,
            // str r0, sp
            0b1110_0110, 0b0000_0000, 0b0001_0000, 0b1101_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // ldr r1, sp
            0b1110_0110, 0b0000_0000, 0b0000_0001, 0b1101_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // hlt
            0b1110_0000, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
        ]);
        while !sys.halted() {
            sys = sys.step();
        }
        assert_eq!(sys.get_reg(1), 255);
    }
    #[test]
    fn test_push_pop() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // mov r0, #255
            // push r0
            // pop r1
            // hlt
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r0, #255
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b1111_1111,
            // push r0
            0b1110_0010, 0b0000_0000, 0b0011_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // pop r1
            0b1110_0010, 0b0000_0000, 0b0010_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // push r0
            0b1110_0010, 0b0000_0000, 0b0011_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // push r0
            0b1110_0010, 0b0000_0000, 0b0011_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // pop r3
            0b1110_0010, 0b0000_0000, 0b0010_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // pop r2
            0b1110_0010, 0b0000_0000, 0b0010_0010, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // hlt
            0b1110_0000, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
        ]);
        while !sys.halted() {
            println!("{}", instr_to_string(sys.get_next_instr()));
            sys = sys.step();
            sys.print();
        }
        assert_eq!(sys.get_reg(0), 255);
        assert_eq!(sys.get_reg(1), 255);
        assert_eq!(sys.get_reg(2), 255);
        assert_eq!(sys.get_reg(3), 255);
        assert_eq!(sys.get_reg(13), MEM_SIZE as u64);
    }
    #[test]
    fn test_recursion() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // f(n) = n + f(n - 1)
            // r0 to r3 are caller saved
            // r4 to r9 are callee saved
            // =f is #40 =end is #120
            // mov r1, #16
            // mov r0, #0
            // nop
            // bl =f
            // hlt
            // f: push lr
            // subs r1, r1, #1
            // beq =end
            // push r1
            // bl =f
            // pop r1
            // add r0, r0, r1
            // pop lr
            // b lr
            // end: mov r0, #0
            // pop lr
            // b lr
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mov r1, #16
            0b1110_0101, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0001_0000,
            // mov r0, #0
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // nop
            0b1110_0100, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // bl =f
            0b1110_0111, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0010_1000,
            // hlt
            0b1110_0000, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // f: push lr
            0b1110_0010, 0b0000_0000, 0b0011_1110, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // subs r1, r1, #1
            0b1110_1101, 0b0000_0000, 0b0010_0001, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // beq =end
            0b0000_0111, 0b0000_0000, 0b0000_0000, 0b0000_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0111_0000,
            // push r1
            0b1110_0010, 0b0000_0000, 0b0011_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // bl =f
            0b1110_0111, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0010_1000,
            // pop r1
            0b1110_0010, 0b0000_0000, 0b0010_0001, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // add r0, r0, r1
            0b1110_0001, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // pop lr
            0b1110_0010, 0b0000_0000, 0b0010_1110, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // b lr
            0b1110_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_1110,
            // end: mov r0, #0
            0b1110_0101, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // pop lr
            0b1110_0010, 0b0000_0000, 0b0010_1110, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // b lr
            0b1110_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_1110,
        ]);
        while !sys.halted() {
            println!("{}", instr_to_string(sys.get_next_instr()));
            sys = sys.step();
        }
        assert_eq!(sys.get_reg(0), 120);
    }
    #[test]
    fn test_int() {
        let mut sys = CoreSys::new();
        sys = sys.load_mem(vec![
            // add r0, r0, #1
            // add r0, r0, #1
            // hlt
            //COND|fIop__code_______________|red|____rea|_reb|____rec_____________________________________________
            // mvi r0
            0b1110_0001, 0b0000_0011, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
            // add r0, r0, #1
            0b1110_0101, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // add r0, r0, #1
            0b1110_0101, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001,
            // hlt
            0b1110_0000, 0b0000_0000, 0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000, 0b0000_0000,
        ]);
        sys = sys.set_int_table(vec![0, 0]);
        let mut first_int = false;
        while !sys.halted() {
            sys = sys.step();
            sys.print();
            if !first_int && sys.get_reg(PC as u64) == 8 {
                sys = sys.interrupt(1, 2);
                first_int = true;
            }
        }
        assert_eq!(sys.get_reg(0), 4);
    }
}
```

当然，写二进制代码还是太反人性了，下文中，我们将实现一个汇编器，这样我们就可以通过汇编代码来执行程序了。

此外，注意，我们只实现了核心系统，I/O等功能只是留下了中断线，实现了中断处理。外设功能将在后文实现。但为了方便测试，我们先实现汇编器。

[Github源码链接](https://github.com/proximal-phalanx/your-own-computer-on-wasm)